namespace Terminal.Gui.ConsoleDrivers.Windows.Interop;

using System.Diagnostics.CodeAnalysis;

// NOTE: This is getting replaced with a struct which handles things better than the enum can in a commit to come later.
/// <summary>
///     Native type for Windows interop.<br/>
///     Bit-flagged value for control of console operation.
/// </summary>
/// <remarks>
///     This type should not be used outside of interop with the Win32 APIs.
/// </remarks>
/// <seealso href="https://learn.microsoft.com/en-us/windows/console/setconsolemode" />
[Flags]
[Obsolete ("Will be replaced by a struct of the same name in a future change.", false)]
[SuppressMessage (
                     "ReSharper",
                     "InconsistentNaming",
                     Justification = "Following recommendation to keep types named the same as the native types.")]
internal enum CONSOLE_MODE : uint
{
    /// <summary>
    ///     Explicit zero value for .net formality. No flags set.
    /// </summary>
    None = 0,

    /// <summary>
    ///     CTRL+C is processed by the system and is not placed in the input buffer.<br/>
    ///     If the input buffer is being read by ReadFile or ReadConsole, other control keys are processed by the system and are not
    ///     returned in the ReadFile or ReadConsole buffer.<br/>
    ///     If the ENABLE_LINE_INPUT mode is also enabled, backspace, carriage return, and line feed characters are handled by the
    ///     system.
    /// </summary>
    ENABLE_PROCESSED_INPUT = 0x00000001,

    /// <summary>
    ///     The ReadFile or ReadConsole function returns only when a carriage return character is read.<br/>
    ///     If this mode is disabled, the functions return when one or more characters are available.
    /// </summary>
    ENABLE_LINE_INPUT = 0x00000002,

    /// <summary>
    ///     Characters read by the ReadFile or ReadConsole function are written to the active screen buffer as they are typed into the
    ///     console.
    /// </summary>
    /// <remarks>
    ///     This mode can be used only if the ENABLE_LINE_INPUT mode is also enabled.
    /// </remarks>
    ENABLE_ECHO_INPUT = 0x00000004,

    /// <summary>
    ///     User interactions that change the size of the console screen buffer are reported in the console's input buffer.<br/>
    ///     Information about these events can be read from the input buffer by applications using the ReadConsoleInput function, but not
    ///     by those using ReadFile or ReadConsole.
    /// </summary>
    ENABLE_WINDOW_INPUT = 0x00000008,

    /// <summary>
    ///     If the mouse pointer is within the borders of the console window and the window has the keyboard focus, mouse events
    ///     generated by mouse movement and button presses are placed in the input buffer. These events are discarded by ReadFile or
    ///     ReadConsole, even when this mode is enabled.<br/>
    ///     The ReadConsoleInput function can be used to read MOUSE_EVENT input records from the input buffer.
    /// </summary>
    ENABLE_MOUSE_INPUT = 0x00000010,

    /// <summary>
    ///     When enabled, text entered in a console window will be inserted at the current cursor location and all text following that
    ///     location will not be overwritten.<br/>
    ///     When disabled, all following text will be overwritten.
    /// </summary>
    ENABLE_INSERT_MODE = 0x00000020,

    /// <summary>
    ///     This flag enables the user to use the mouse to select and edit text.
    /// </summary>
    /// <remarks>
    ///     To enable this mode, use <see cref="ENABLE_QUICK_EDIT_MODE"/> | <see cref="ENABLE_EXTENDED_FLAGS"/>.<br/>
    ///     To disable this mode, use <see cref="ENABLE_EXTENDED_FLAGS"/> without this flag.
    /// </remarks>
    ENABLE_QUICK_EDIT_MODE = 0x00000040,

    /// <summary>
    ///     Required flag to enable or disable certain other flags.
    /// </summary>
    ENABLE_EXTENDED_FLAGS = 0x00000080,

    /// <summary>
    ///     Undocumented.
    /// </summary>
    ENABLE_AUTO_POSITION = 0x00000100,

    /// <summary>
    ///     Setting this flag directs the Virtual Terminal processing engine to convert user input received by the console window into
    ///     Console Virtual Terminal Sequences that can be retrieved by a supporting application through ReadFile or ReadConsole
    ///     functions.
    /// </summary>
    /// <remarks>
    ///     The typical usage of this flag is intended in conjunction with <see cref="ENABLE_VIRTUAL_TERMINAL_PROCESSING"/> on the output
    ///     handle to
    ///     connect to an application that communicates exclusively via virtual terminal sequences.
    /// </remarks>
    ENABLE_VIRTUAL_TERMINAL_INPUT = 0x00000200,

    /// <summary>
    ///     Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are parsed for
    ///     ASCII control sequences, and the correct action is performed. Backspace, tab, bell, carriage return, and line feed characters
    ///     are processed.<br/>It should be enabled when using control sequences or when <see cref="ENABLE_VIRTUAL_TERMINAL_PROCESSING"/>
    ///     is set.
    /// </summary>
    ENABLE_PROCESSED_OUTPUT = 0x00000001,

    /// <summary>
    ///     When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the
    ///     next row when it reaches the end of the current row. This causes the rows displayed in the console window to scroll up
    ///     automatically when the cursor advances beyond the last row in the window. It also causes the contents of the console screen
    ///     buffer to scroll up (../discarding the top row of the console screen buffer) when the cursor advances beyond the last row in
    ///     the console screen buffer.<br/>
    ///     If this mode is disabled, the last character in the row is overwritten with any subsequent characters.
    /// </summary>
    ENABLE_WRAP_AT_EOL_OUTPUT = 0x00000002,

    /// <summary>
    ///     When writing with WriteFile or WriteConsole, characters are parsed for VT100 and similar control character sequences that
    ///     control cursor movement, color/font mode, and other operations that can also be performed via the existing Console APIs. For
    ///     more information, see Console Virtual Terminal Sequences.
    /// </summary>
    /// <remarks>
    ///     Ensure <see cref="ENABLE_PROCESSED_OUTPUT"/> is set when using this flag.
    /// </remarks>
    ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x00000004,

    /// <summary>
    ///     When writing with WriteFile or WriteConsole, this adds an additional state to end-of-line wrapping that can delay the cursor
    ///     move and buffer scroll operations.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         Normally when <see cref="ENABLE_WRAP_AT_EOL_OUTPUT"/> is set and text reaches the end of the line, the cursor will
    ///         immediately move to the next line and the contents of the buffer will scroll up by one line. In contrast with this flag
    ///         set, the cursor does not move to the next line, and the scroll operation is not performed. The written character will be
    ///         printed in the final position on the line and the cursor will remain above this character as if
    ///         <see cref="ENABLE_WRAP_AT_EOL_OUTPUT"/> was off, but the next printable character will be printed as if
    ///         <see cref="ENABLE_WRAP_AT_EOL_OUTPUT"/> is on. No overwrite will occur. Specifically, the cursor quickly advances down to
    ///         the following line, a scroll is performed if necessary, the character is printed, and the cursor advances one more
    ///         position.
    ///     </para>
    ///     <para>
    ///         The typical usage of this flag is intended in conjunction with setting <see cref="ENABLE_VIRTUAL_TERMINAL_PROCESSING"/>
    ///         to better emulate a terminal emulator where writing the final character on the screen (../in the bottom right corner)
    ///         without triggering an immediate scroll is the desired behavior.
    ///     </para>
    /// </remarks>
    DISABLE_NEWLINE_AUTO_RETURN = 0x00000008,

    /// <summary>
    ///     <para>
    ///         The APIs for writing character attributes including WriteConsoleOutput and WriteConsoleOutputAttribute allow the usage of
    ///         flags from character attributes to adjust the color of the foreground and background of text. Additionally, a range of
    ///         DBCS flags was specified with the COMMON_LVB prefix. Historically, these flags only functioned in DBCS code pages for
    ///         Chinese, Japanese, and Korean languages.
    ///     </para>
    ///     <para>
    ///         With exception of the leading byte and trailing byte flags, the remaining flags describing line drawing and reverse video
    ///         (../swap foreground and background colors) can be useful for other languages to emphasize portions of output.
    ///     </para>
    ///     Setting this console mode flag will allow these attributes to be used in every code page on every language.
    ///     <para>
    ///     </para>
    ///     <para>
    ///         It is off by default to maintain compatibility with known applications that have historically taken advantage of the
    ///         console ignoring these flags on non-CJK machines to store bits in these fields for their own purposes or by accident.
    ///     </para>
    ///     <para>
    ///         Note that using the ENABLE_VIRTUAL_TERMINAL_PROCESSING mode can result in LVB grid and reverse video flags being set
    ///         while this flag is still off if the attached application requests underlining or inverse video via Console Virtual
    ///         Terminal Sequences.
    ///     </para>
    /// </summary>
    ENABLE_LVB_GRID_WORLDWIDE = 0x00000010
}
